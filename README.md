# Приближение минимальной степени остовного дерева с точностью до единицы от оптимальной степени
## Постановка задачи
Дан ненаправленный связный граф $G = (V, E)$, требуется найти его остовное дерево, т. е. подграф, который является деревом и в котором участвуют все вершины,
такое что максимальная степень вершины в этом дереве минимально возможна.
* [Доказательство NP-полноты и описание алгоритма с анализом асимптотики](DESCRIPTION.md)
* [Анализ собранной статистики запуска тестов, оценки производительности и профилирования](analysis/analysis.ipynb)
* [Approximating the Minimum Degree Spanning Tree to within One from the Optimal Degree](https://dl.acm.org/doi/pdf/10.5555/139404.139469)

## Структура репозитория
```bash
ComplexityProject
├── analysis                        -- анализ собранной статистики запуска тестов, оценки производительности и профилирования
│   ├── analysis.ipynb
│   └── profile.svg                     -- flamegraph построенный в ходе профилирования
├── benchmark                       -- оценка производительности с использованием benchmark
│   ├── complete_graph.cpp              -- оценка на полных графах
│   └── random_graph.cpp                -- оценка на случайных графах
├── CMakeLists.txt
├── data                            -- здесь располагаются наборы графов
│   └── graphs.md                       -- описание используемых наборов графов
├── DESCRIPTION.md                  -- доказательство NP полноты задачи MDST(k) и описание приближённого алгоритма
├── main.cpp                        -- консольная программа для запуска алгоритма с вводом/выводом через стандартные потоки
├── README.md                       
├── src                             -- код алгоритма и необходимые структуры для него
│   ├── dsu(.cpp/.hpp)                  -- структура данных система непересекающихся множеств
│   ├── graphs                          -- классы для работы с графами
│   │   ├── edge_list(.cpp/.hpp)            -- граф как список рёбер
│   │   └── linked_list(.cpp/.hpp)          -- граф как связный список
│   └── spanning_tree(.cpp/.hpp)        -- алгоритм построения и приближённой минимизации степени остовного дерева
├── tests                           -- тесты с использованием googletests
│   ├── checks                          -- различные проверки остовного дерева
│   │   ├── connectivity(.cpp/.hpp)         -- проверяет связность графа
│   │   ├── optimal.hpp                     -- решает задачу MDST(k) используя CP-solver из OR-Tools
│   │   ├── tree(.cpp/.hpp)                 -- проверяет, что граф является деревом
│   │   └── united_check(.cpp/.hpp)         -- запускает остальные проверки и собирает статистику
│   ├── random_tests.cpp                -- тесты на случайных графах
│   ├── read_graph                      -- тесты на наборах готовых графов
│   │   ├── graph_reader.hpp                -- класс для последовательного чтения графов из файла
│   │   ├── read_graph.cpp                  -- инициализация тестов
│   │   └── showg.cpp                       -- исходник программы showg, необходимый для чтения графов в форматах graph6, sparse6 и digraph6
│   └── simple_tests.cpp                -- тесты на полных графах и тест с пользовательским вводом
└── workloads.cpp                   --  рабочая нагрузка для профилирования алгоритма
```

## Сборка и запуск
* Сборка осуществляется средствами `cmake`.
* После успешной сборки будут получены следующие исполняемые файлы в `build/bin`:
    * `test` — запуск тестов.
    * `perfomance` — запуск оценки производительности.
    * `workloads` — запуск рабочей нагрузки для профилирования алгоритма.
    * `spanning_tree` — консольная утилита. 
        * На стандартный входной поток принимает граф $G$ в формате: `<число вершин n> <число рёбер m> <список рёбер, m пар чисел от 0 до n-1>`
        * На стандартный выходной поток выводит найденное остовное дерево в фломате: `<n> <n-1> <n-1 пара чисел от 0 до n-1>`
* Перед запуском тестов необходимо поместить наборы графов в [`data`](data/graphs.md).
* Чтобы включить сбор статистики при запуске тестов, необходимо установить переменную окружения `STATISTICS=1`, например следующим образом:
```bash
$ STATISTICS=1 ./test --gtest_output=json
```

## Используемые библиотеки и фреймворки
* Для тестирования используется фреймворк [googletest](https://github.com/google/googletest)
* Для проверки корректности и оптимальности решения используется $\sf{CP}$-solver из библиотеки [OR-Tools](https://developers.google.com/optimization)
* Для оценки производительности получившегося алгоритма используется фреймворк [benchmark](https://github.com/google/benchmark)
* Для создания тестов используются наборы графов с [cecs.anu.edu.au](https://users.cecs.anu.edu.au/~bdm/data/graphs.html), которые необходимо поместить в папку `data` до запуска тестов. Какие именно наборы используются можно узнать [здесь](data/graphs.md).
* Для чтения наборов графов в форматах graph6, sparse6 и digraph6 используется изменённая программа [showg.c](https://users.cecs.anu.edu.au/~bdm/data/showg.c) 
